#!/usr/bin/python

#Extensional Proof of Accuracy of Unpwn for Pwqgen.rb output :

#This script takes in a text file generated by running pwqgen.rb 400 000 times using a bash script, called "samplesize".
#It then undergoes the following steps:
#   1.  Splits each line from the pwqgen.rb output where it finds the first seperator. 
#       E.g. (Aey_Bee+cee -> Aey_ into left[] and Bee+cee into right[])
#   2.  Imports the data used to generate the proper combinations to check against Troy Hunt's password hashlist for the Left size.
#   3.  Checks actual pwqgen.rb Left output against the combinatorial data used in Unpwn, and counts the number of hits.
#       I.e. if pwqgen.rb produces a password that is not caught by Unpwn, then No. of hits < Size of Left[].
#       In other words, Unpwn did not test that password against Troy Hunt's database. It is possible that it has been pwned, but does not appear in the unpwn list.
#   4.  The cominatorial data for the right side is extremely large, and does not fit in my system's memory. As such, steps 2 and 3 are repeated for the right combinatorial data in 6 steps, by calling rightparse(n).
#   5.  The number of hits for the left, right, and in total, are calculated to give a percentage of hits. 
#       I.e. if this tally is 50%, then any pwqgen.rb output that doesn't exist in Unpwn has a 50% chance of not being in the pwned passwords list.
#       The ideal is 100%.

#Details provided at each step

# Step 1.   Parsing 400 000 pwqgen.rb outputs

f = open("samplesize", "r")
left = []
right = []
seperators = "-_!$&*+=23456789" #Taken from pwqgen.rb code
print("Parsing the 400 000 output from pwqgen.rb")
for line in f:
    if line[len(line)-6:] == 'FALSE\n': 
# While generating the 400 000, my Ruby interpreter crashed. As a result, it produced "FALSE" for the last segment of 59 passwords, interspersed throughout "samplesize". This line tells the script to ignore these erroneous outputs.
        continue
    else:
        for ichar in range(0, len(line)):
            if line[ichar] in seperators:
                if ichar == 1 or ichar == 2 or ichar == 4:
                    if line[:ichar] == "T" or line[:ichar] == "Yo" or line[:ichar] == "Felt" or line[:ichar] == "Drop": 
# This line is necessary, because "-" occurs in both the seperators and the EFF wordlists, which will cause problems if Left ends up being a word such as "T-Shirt".
                        continue
                    else:
                        left.append(line[:ichar+1])
                        right.append(line[ichar+1:len(line)-1])
                        break
                else:
                    left.append(line[:ichar+1])
                    right.append(line[ichar+1:len(line)-1])
                    break


if len(left) != len(right): #Check to make sure that the loops above didn't go wrong
    print("Something went wrong.")
    raise

f.close()

#Step 2.    Importing the combinatorial data used in Unpwn for the Left side.

print("Parsing successful.\nImporting data used for the left side")

le = open("REFINED_left.txt", "r")

data_left = []

lscore = 0 # These values are the number of hits for left and right.
rscore = 0

for lentry in le:
    data_left.append(lentry[:len(lentry)-1])

le.close()

# Step 3.   Calculate hits and hit ratio for Left
print("Import successful. Now tallying number of entries in sample which falls in the refined left dataset")
dataset_left = set(data_left) # Converts the combinatorial data from a Python list to a set, as it speeds up the process tremendously.
for lent in left:
    if lent in dataset_left:
        lscore += 1 # Tallying the number of hits into lscore

ltally = lscore/(len(left)) # Dividing hits by the total number of entries in Left, to get a percentage.

print("Left side analysis complete. Vkravens refinements for the left are " + str(ltally*100) + "% accurate.\nNow clearing left data from memory.")

# Clears data to free memory
data_left = 0
left = 0

# Step 4.   Repeats steps 2 and 3 for Right.

negright = set(right) # Converts the pwqgen.rb 400 000 right output into a set, to speed up existence checks and to use python set operations.
baseright = set(right) # Preserves a copy of the set of elements in Right, for score percentage calculations and error checking. (Sets are unordered and do not count duplicates, so len(baseright) <= len(right).

def rightparse(n):
    global negright
    global rscore
    data_right = []
    if n == 0:
        print("First right dataset")
        ri = open("REFINED_rightaa_aa", "r")
    elif n == 1:
        print("Right dataset 1 complete. Now importing dataset 2")
        ri = open("REFINED_rightaa_ab", "r")
    elif n == 2:
        print("Right dataset 2 complete. Now importing dataset 3")
        ri = open("REFINED_rightab_aa", "r")
    elif n == 3:
        print("Right dataset 3 complete. Now importing dataset 4")
        ri = open("REFINED_rightab_ab", "r")
    elif n == 4:
        print("Right dataset 4 complete. Now importing dataset 5")
        ri = open("REFINED_rightac_aa", "r")
    elif n == 5:
        print("Right dataset 5 complete. Now importing final dataset")
        ri = open("REFINED_rightac_ab", "r")
    else:
        print("Error, unknown round")
        raise

    for rentry in ri:
       data_right.append(rentry[:len(rentry)-1])

    dataset_right = set(data_right)
    data_right = 0

    ri.close()

# Scoring right
    for rent in negright:
        if rent in dataset_right:
            rscore += 1

#Removing hits from negright
    negright = negright - dataset_right
    dataset_right = 0 #Clearing memory


print("Right dataset is too large to fit in my memory and swap space on python. Parsing it in six steps.")

for i in range(0,6):
    rightparse(i)

if len(negright) != 0:
    print("Alert.")

# Step 5.   Tallying of results to give an accuracy percentage
rtally = rscore/(len(baseright))

totaltally = (ltally + rtally)/2

print("Vkravens refinements are :\nLeft:\t" + str(ltally*100) +"%\nRight:\t" + str(rtally*100) + "%\nTotal:\t" + str(totaltally*100) +"% accurate.")

# See output.md for a the output of this script in the python interpreter, and the completion of the proof.
